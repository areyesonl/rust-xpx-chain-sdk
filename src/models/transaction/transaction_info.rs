use crate::models::account::PublicAccount;
use crate::models::transaction::{deadline::Deadline, TransactionType};
use crate::models::transaction::EntityVersion;
use crate::models::Uint64;

#[derive(Debug, PartialEq, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct AbstractTransaction {
    pub(crate) transaction_info: Option<TransactionInfo>,

    /// The signature was generated by the signer and can be used to validate tha the entity
    /// data was not modified by a node.
    pub(crate) signature: String,

    /// The 'PublicAccount' of the entity signer formatted as hexadecimal.
    pub(crate) signer: PublicAccount,

    /// The transaction version.
    pub(crate) version: EntityVersion,

    /// The transaction type.
    #[serde(rename = "type")]
    pub(crate) transaction_type: TransactionType,

    /// The maximum fee allowed to be spent for this transaction.
    ///
    /// The higher the fee, the higher the priority of the transaction. Transactions with high
    /// priority get included in a block before transactions with lower priority.
    pub(crate) max_fee: Uint64,

    /// The 'Deadline' for the transaction to be included in a block before it expires.
    pub(crate) deadline: Deadline,
}

impl AbstractTransaction {
    pub fn new(tx_info: Option<TransactionInfo>,
               signature: String,
               signer: PublicAccount,
               version: EntityVersion,
               transaction_type: TransactionType,
               max_fee: Uint64,
               deadline: Deadline,
    ) -> Self {
        AbstractTransaction {
            transaction_info: tx_info,
            signature,
            signer,
            version,
            transaction_type,
            max_fee,
            deadline,
        }
    }

    pub(crate) fn is_unconfirmed(&self) -> bool {
        return if let Some(tx_info) = &self.transaction_info {
            tx_info.height.0.to_owned() == 0 &&
                tx_info.transaction_hash.eq(&tx_info.merkle_component_hash)
        } else {
            false
        };
    }

    pub(crate) fn is_confirmed(&self) -> bool {
        return if let Some(tx_info) = &self.transaction_info {
            tx_info.height.0 > 0
        } else {
            false
        };
    }

    pub(crate) fn has_missing_signatures(&self) -> bool {
        return if let Some(tx_info) = &self.transaction_info {
            tx_info.height.0 == 0 && tx_info.transaction_hash.eq(
                &tx_info.merkle_component_hash
            )
        } else {
            false
        };
    }

    pub(crate) fn is_unannounced(&self) -> bool {
        unimplemented!()
    }

    pub(crate) fn to_aggregate(&mut self, signer: PublicAccount) {
        self.signer = signer
    }
}

impl core::fmt::Display for AbstractTransaction {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        write!(
            f, "{}",
            serde_json::to_string_pretty(&self).unwrap_or_default()
        )
    }
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct TransactionInfo {
    pub height: Uint64,
    pub index: u32,
    pub id: String,
    pub transaction_hash: String,
    pub merkle_component_hash: String,
    pub agregate_hash: String,
    pub aggregate_id: String,
}

impl TransactionInfo {
    pub fn new(
        height: Uint64,
        index: u32,
        id: String,
        transaction_hash: String,
        merkle_component_hash: String,
        agregate_hash: String,
        aggregate_id: String,
    ) -> Self {
        TransactionInfo {
            height,
            index,
            id,
            transaction_hash,
            merkle_component_hash,
            agregate_hash,
            aggregate_id,
        }
    }
}

impl core::fmt::Display for TransactionInfo {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        write!(
            f, "{}",
            serde_json::to_string_pretty(&self).unwrap_or_default()
        )
    }
}
